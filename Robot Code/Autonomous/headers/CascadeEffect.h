#pragma config(StandardModel, "PS CASCADE EFFECT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
*	CascadeEffect.h
*	Game-specific functions and routines for the 2014-15 FTC game.
*	Copyright (C) 2015 Powerstackers
*
*	This program is free software: you can redistribute it and/or modify
*	it under the terms of the GNU General Public License as published by
*	the Free Software Foundation, either version 3 of the License, or
*	(at your option) any later version.
*
*	This program is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*
*	You should have received a copy of the GNU General Public License
*	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*	FTC Team #5029, The Powerstackers
*	powerstackersftc.com
*	github.com/powerstackers
*	January 20 2015
*	Version 0.4
*/

#include "AutoFunctions.h"
#include "CollisionAvoidance.h"
#include "../../Robot.h"

// Game functions
char findGoalOrientation();
void dropBall(long height);
void kickstand();

// Manipulator movement functions
void moveMotorTo(short affectedMotor, long position, short speed);

// Macros for the different positions of the center goal
// The number indicates the average reading for the IR sensors when the goal is at that position
#define positionA 80
#define positionB 95
#define positionC 70

// Macros to store the different position names
#define CENTGOAL_POSITION_A 'a'
#define CENTGOAL_POSITION_B 'b'
#define CENTGOAL_POSITION_C 'c'

/*
*	findGoalOrientation
*	Find which way the center goal is facing
*/
char findGoalOrientation()
{
	writeDebugStreamLine("-- FINDING CENTER GOAL ORIENTATION --");

	// Read the average of the IR seeker
	int avg = getIRStrength();

	// Find the difference between the average IR signal and the known values for each position
	int diffA = abs(avg - positionA);
	int diffB = abs(avg - positionB);
	int diffC = abs(avg - positionC);

	// The lowest difference is the position the center goal is facing
	char facing;	// Create a variable to store the decision
	if(diffA < diffB && diffA < diffC)		// If the difference in position a is lowest, the tower must be in position a
		facing = CENTGOAL_POSITION_A;
	else if(diffB < diffA && diffB < diffC)	// If the difference in position b is lowest, the tower must be in position b
		facing = CENTGOAL_POSITION_B;
	else									// If the tower isn't in position a or b, default to position c
		facing = CENTGOAL_POSITION_C;

	// Print the IR reading, the differences, and the answer to the debug stream
	writeDebugStreamLine("\tIR:\t%d", avg);
	writeDebugStreamLine("\tdiifA:", diffA);
	writeDebugStreamLine("\tdiffB:", diffB);
	writeDebugStreamLine("\tdiffC:", diffC);
	writeDebugStreamLine("\tThe thing is in position %c", facing);

	// Return the direction that the center goal is facing
	return facing;
}

/*
*	dropBall
*	Dropping the balls into the tubes
*/
void dropBall(long height)
{
	// put the grabber down,
	moveMotorTo(mTip, nMotorEncoder[mTip]+tipTargetFloor, tipMotorSpeed);
	//then move forward a little,
	goTicks(inchesToTicks(-10), 50);
	//then t-rex hand have to go down.
	servo[rGrabber]=grabberClosedPosition;
	//lift hpper,
	//moveMotorTo(mLift, height, liftMotorSpeed);
	//then trap door has to drop,
	//servo[rTrapDoor]=trapDoorOpenPosition;
	//then wait,
	//wait10Msec (300);
	//put the trap door back up
	//servo[rTrapDoor]=trapDoorClosedPosition;
	// put the lift down.
	//moveMotorTo(mLift, liftTargetBase, liftMotorSpeed);
}

/*
*	kickstand
*	Knock over the kickstand
*/
void kickstand()
{

}

/*
*	moveMotor
*	Move a motor to a given encoder position
*/
void moveMotorTo(short affectedMotor, long position, short speed)
{
	writeDebugStreamLine("-- MOVING MOTOR TO POSITION --\n\tCurrent position: %d", nMotorEncoder[affectedMotor]);
	writeDebugStreamLine("\tTarget position: %d", position);
	// If the motor is already at the target position, don't change it
	if(nMotorEncoder[affectedMotor]==position)
	{
		return;
	}
	else
	{
		// If the motor is below the target position, move up
		if(position>nMotorEncoder[affectedMotor])
		{
			motor[affectedMotor]= speed;
			while(position>nMotorEncoder[affectedMotor]){}
		}
		// If the motor is above the target position, move down
		else
		{
			motor[affectedMotor]= -speed;
			while(position<nMotorEncoder[affectedMotor]){}
		}

		// Turn off the motor
		motor[affectedMotor]=0;
	}

	writeDebugStreamLine("-- MOTOR MOVED --");
}
