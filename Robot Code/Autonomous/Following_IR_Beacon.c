#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S2,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     mLeft,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     mRight,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
*	Minibot.c
*	Code to run our demonstration minibot, which will follow a moving IR beacon.
*	Copyright (C) 2015 Powerstackers
*
*	Some code borrowed from Xander Soldaat, 2010 (mightor@gmail.com)
*
*	This program is free software: you can redistribute it and/or modify
*	it under the terms of the GNU General Public License as published by
*	the Free Software Foundation, either version 3 of the License, or
*	(at your option) any later version.
*
*	This program is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*
*	You should have received a copy of the GNU General Public License
*	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*	FTC Team #5029, The Powerstackers
*	powerstackersftc.com
*	github.com/powerstackers
*	January 16 2015
*	Version 0.1
*/

#include "../Drivers/hitechnic-irseeker-v2.h"

// main task
task main ()
{
	int _dirAC = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	int maxSig = 0;    // the max signal strength from the seeker.
	int val = 0;       // the translated directional value.

	// we are going to set DSP mode to 1200 Hz.
	tHTIRS2DSPMode _mode = DSP_1200;

	// attempt to set to DSP mode.
	if (HTIRS2setDSPMode(HTIRS2, _mode) == 0)
	{
		// unsuccessful at setting the mode.
		// display error message.
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "ERROR!");
		nxtDisplayCenteredTextLine(2, "Init failed!");
		nxtDisplayCenteredTextLine(3, "Connect sensor");
		nxtDisplayCenteredTextLine(4, "to Port 2.");

		// make a noise to get their attention.
		PlaySound(soundBeepBeep);

		// wait so user can read message, then leave main task.
		wait10Msec(300);
		return;
	}

	eraseDisplay();

	// loop continuously and read from the sensor.
	while( true )  //while(maxSig<200)
	{
		// read the current modulated signal direction
		_dirAC = HTIRS2readACDir(HTIRS2);
		if (_dirAC < 0)
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read dir ERROR!");
			break;
		}

		// Get the AC signal strength values.
		if (!HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5 ))
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read sig ERROR!");
			break;
		}
		else
		{
			// find the max signal strength of all detectors.
			maxSig = (acS1 > acS2) ? acS1 : acS2;
			maxSig = (maxSig > acS3) ? maxSig : acS3;
			maxSig = (maxSig > acS4) ? maxSig : acS4;
			maxSig = (maxSig > acS5) ? maxSig : acS5;
		}

		// display info
		nxtDisplayCenteredBigTextLine(1, "Dir=%d", _dirAC);
		nxtDisplayCenteredBigTextLine(4, "Sig=%d", maxSig);

		// first translate directional index so 0 is straight ahead.
		val = _dirAC - 5;

		// If the beacon is within a few centimeters of the detector, stop the robot
		if(maxSig > 200)
		{
			motor[mLeft] = 0;
			motor[mRight] = 0;
		}

		// Turn the robot to the left
		else if (_dirAC > 5)
		{
			motor[mLeft]=30;
			motor[mRight]=0;
		}
		// Turn the robot to the right
		else if (_dirAC < 5)
		{
			motor[mLeft]=0;
			motor[mRight]=30;
		}

		// If the beacon can't be found, spin in a circle until you find it again
		else if(maxSig < 20)
		{
			motor[mRight] = 30;
			motor[mLeft] = -30;
		}

		// Just drive straight
		else
		{
			motor[mLeft]=50;
			motor[mRight]=50;
		}
	}
}
