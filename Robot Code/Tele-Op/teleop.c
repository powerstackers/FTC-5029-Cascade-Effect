#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUX,           sensorNone)
#pragma config(Sensor, S3,     sGyro,          sensorNone)
#pragma config(Sensor, S4,     sLiftStop,      sensorNone)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBrush,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Include a file to handle messages from the joystick
#include "JoystickDriver.c"


short stick_value_left_forward;
short stick_value_right_forward;
short stick_value_left_backward;
short stick_value_right_backward;

bool button_straight_drive;
bool button_backwards_drive;

void get_custom_joystick_settings ()
{
	stick_value_right_forward = joystick.joy1_y2;
	stick_value_left_forward = joystick.joy1_y1;
	stick_value_right_backward = -1 * joystick.joy1_y1;
	stick_value_left_backward = -1 * joystick.joy1_y2;

	button_straight_drive = (joy1Btn(3) == 1);
	button_backwards_drive = (joy1Btn(5) == 1);

}


/*
*	stickToMotorValue
*	Convert the -127 - 128 stick value to a -100 - 100 motor value
*/
short stick_to_motor_value(short stickValue)
{
	return (short) ( (float)stickValue * 0.78125);
}

/*
*	initializeRobot
*	Sets the robot's motors and servos to their starting values. Also
*	prepares sensors and multiplexers, as well as the NXT.
*/
void initializeRobot()
{

}

task main()
{
	// Sets robot to starting positions
	initializeRobot();

	// Wait for the start of the match
	waitForStart();

	// Clear the display
	bDisplayDiagnostics = false;
	eraseDisplay();

	// Loop forever
	while(true)
	{
		// Updates joystick settings
		getJoystickSettings(joystick);

		get_custom_joystick_settings ();

		/*
		*
		*	Print information to the NXT screen
		*
		*/
		nxtDisplayTextLine(1, "LeftDr:%d", motor[mDriveLeft]);		// Left drive motor settings
		nxtDisplayTextLine(2, "RightDr:%d", motor[mDriveRight]);	// Right drive motor settings
		nxtDisplayTextLine(3, "LeftSt:%d", stick_value_left_forward);			// Left joystick
		nxtDisplayTextLine(4, "RightSt:%d", stick_value_right_forward);		// Right joystick
		nxtDisplayTextLine(5, "RB:%d", stick_value_right_backward);
		nxtDisplayTextLine(6, "LB:%d", stick_value_left_backward);

		// STRAIGHT DRIVE
		// If button 3 on joystick 1 is pressed
		if(button_straight_drive)
		{
			// Move both motors together based on left joystick position
			motor[mDriveLeft] = (abs(stick_value_left_forward) > 15)? stick_to_motor_value(stick_value_left_forward) : 0;
			motor[mDriveRight] = (abs(stick_value_left_forward) > 15)? stick_to_motor_value(stick_value_left_forward) : 0;
		}
		// BACKWARDS DRIVE
		// If button 5 is pressed
		else if(button_backwards_drive)
		{
			motor[mDriveLeft] = (abs(stick_value_left_backward) > 15)? stick_to_motor_value(stick_value_left_backward) : 0;
			motor[mDriveRight] = (abs(stick_value_right_backward) > 15)? stick_to_motor_value(stick_value_right_backward) : 0;
		}
		// NORMAL DRIVE
		// If button 3 on joystick 1 is not pressed
		else
		{
			// Move the motors independently, based on their respective joystick positions
			motor[mDriveLeft] = (abs(stick_value_left_forward) > 15)? stick_to_motor_value(stick_value_left_forward) : 0;
			motor[mDriveRight] = (abs(stick_value_right_forward) > 15)? stick_to_motor_value(stick_value_right_forward) : 0;
		}

		// If button 6 on joystick 1 is pressed, set the brush motor to full power.
		// If it is not pressed, set the brush motor to 0.
		motor[mBrush] = (joy1Btn(6) == 1)? -100 : 0;

	}
}
